# ================ENUMS================
enum Flavour {
	PRO
	CONSUMER
}

enum UserType {
	CLIENT
	HEALTHCAREWORKER
}

enum Gender {
	MALE
	FEMALE
	OTHER
}

enum ContactType {
	PRIMARY
	SECONDARY
    OFFICIAL
}

enum ContentType {
	VIDEO
	AUDIO
	ARTICLE
}

enum ClientType {
	PMTCT
	OVC
}

enum AddressType {
	POSTAL
	PHYSICAL
	BOTH
}

enum RelationshipType {
	NEXT_OF_KIN
	EMPLOYER
	EMERGENCY_CONTACT
	CHILD
	OTHER
}

# ================TYPES================
type Contact {
	contactType: ContactType!
	contact: String!
	active: Boolean!
	optedIn: Boolean!
}

type User {
    userName: String!
    displayName: String!
    firstName: String!
    middleName: String
    lastName: String!
    userType: UserType!
    gender: Gender!
    active: Boolean!
    contacts: [Contact!]!
    languages: [String]
    termsAccepted: Boolean!
}

type Address {
	addressType: AddressType!
	text: String!
	country: String!
	postalCode: String
	county: String
	active: Boolean!
}

type RelatedPerson {
	active: Boolean!
	relatedTo: String!
	relationshipType: RelationshipType!
	firstName: String!
	lastName: String!
	otherName: String
	gender: Gender!
	dateOfBirth: String!
	addresses: [Address!]
	contacts: [Contact!]
}

type ClientProfile {
	user: User!
	treatmentEnrollmentDate: String
	clientType: ClientType!
	active: Boolean!
	addresses: [Address!]!
	relatedPersons: [RelatedPerson]
	facilityID: String!
	treatmentBuddy: String
	clientCounselled: Boolean!
}

type AuthCredentials  {
	refreshToken: String!
	idToken: String!
	expiresIn: String!
}

type AuthCredentialsResponse {
	authCredentials: AuthCredentials!
	clientProfile: ClientProfile!
}

type Terms  {
	text: String! 
	flavour: Flavour! 
}

type LoginResponse  {
	credentials: AuthCredentialsResponse!
	code: String! 
	message: String 
}

type SecurityQuestion {
	questionStem: String!
	description: String
	flavour: Flavour!
	active: Boolean!
}

type SecurityQuestionResponse {
	userID: String!
	securityQuestionID: String!
	response: String!
}

type VerifyOTPResponse {
	response: Boolean!
	code: String
}

type Content {
	title: String!
	body: String!
	author: String!
	authorAvatar: String!
	heroImage: String!
	contentType: ContentType!
	publicLink: String!
	isNew: Boolean!
	estimate: String!
	tags: [String]!
	createdAt: String!
}

# ================INPUTS================
input SecurityQuestionResponseInput {
	userID: String!
	securityQuestionID: String!
	response: String!
}

# ================QUERIES================
type Query  {
	# Onboarding apis
	login(phoneNumber: String!, pin: String!, flavour: Flavour!): LoginResponse! @lambda 
	setUserPIN(userID: String!, pin: String!, confirmPin: String!, flavour: Flavour!): Boolean! @lambda
	verifyPIN(userID: String!, pin: String!, confirmPin: String!, flavour: Flavour!): Boolean! @lambda
	sendOTP(userID: String!, flavour: Flavour!): String! @lambda
	resendOTP(userID: String!, flavour: Flavour!): String! @lambda
	verifyOTP(userID: String!, otp: String!, flavour: Flavour!): VerifyOTPResponse! @lambda
	getSecurityQuestions(flavour: Flavour!): [SecurityQuestion]! @lambda
	listTerms(flavour: Flavour!): Terms! @lambda

	# TODO: add update user profile api

	# Home page apis
	fetchContent(limit: Int!, tags: [String!]!): [Content!]! @lambda
}

# ================MUTATIONS================
type Mutation  {
	reviewTerms(userID: String!, accepted: Boolean!, flavour: Flavour!): Boolean! @lambda 
	recordSecurityQuestionResponses(input: [SecurityQuestionResponseInput!]!): Boolean! @lambda
}
